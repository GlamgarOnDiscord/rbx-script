-- ü™ê Steal Brainrot - VERSION COMPL√àTE AM√âLIOR√âE
-- Version ultra-avanc√©e avec toutes les fonctionnalit√©s

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Services
local player = game.Players.LocalPlayer
local workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

-- Variables globales
local DebugMode = true
local WebhookUrl = ""
local WalkSpeed = 16
local AutoStealEnabled = false
local AutoFarmMoney = false
local PlayerStatsEnabled = false

-- Statistiques
local Stats = {
    BrainrotsDetected = 0,
    BrainrotsBought = 0,
    MoneyEarned = 0,
    PlayersStolen = 0,
    SessionStart = tick()
}

-- Fonction de debug avec webhook
local function DebugLog(message, level, sendWebhook)
    if not DebugMode then return end
    local prefix = "ü™ê DEBUG"
    if level == "warn" then
        prefix = "‚ö†Ô∏è WARN"
        warn(prefix .. ": " .. tostring(message))
    elseif level == "error" then
        prefix = "‚ùå ERROR"
        print(prefix .. ": " .. tostring(message))
    elseif level == "success" then
        prefix = "‚úÖ SUCCESS"
        print(prefix .. ": " .. tostring(message))
    else
        print(prefix .. ": " .. tostring(message))
    end
    
    -- Envoyer au webhook Discord si activ√©
    if sendWebhook and WebhookUrl ~= "" then
        SendDiscordWebhook("üìä " .. prefix, tostring(message))
    end
end

-- Fonction webhook Discord
local function SendDiscordWebhook(title, description, color)
    if WebhookUrl == "" then return end
    
    local data = {
        embeds = {{
            title = title,
            description = description,
            color = color or 3447003,
            timestamp = os.date("!%Y-%m-%dT%H:%M:%S.000Z"),
            footer = {
                text = "Steal Brainrot Premium - " .. player.Name
            }
        }}
    }
    
    pcall(function()
        local jsonData = HttpService:JSONEncode(data)
        local request = http_request or request or HttpPost or syn.request
        request({
            Url = WebhookUrl,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = jsonData
        })
    end)
end

-- Fonction de d√©tection automatique de nouveaux patterns
local function LearnNewPatterns(text)
    local textLower = text:lower()
    
    -- D√©tecter si c'est une mutation inconnue (contient des mots-cl√©s typiques)
    local mutationKeywords = {"shiny", "glow", "sparkle", "bright", "dark", "light", "metal", "gem"}
    for _, keyword in pairs(mutationKeywords) do
        if textLower:find(keyword) then
            local found = false
            for _, known in pairs(MUTATION_PATTERNS) do
                if textLower:find(known) then found = true break end
            end
            if not found and not DetectedPatterns.mutations[text] then
                DetectedPatterns.mutations[text] = true
                DebugLog("üîç NOUVELLE MUTATION D√âTECT√âE: " .. text, "success", true)
                table.insert(MUTATION_PATTERNS, textLower)
            end
        end
    end
    
    -- D√©tecter si c'est une raret√© inconnue (format typique de raret√©)
    if textLower:match("^%a+$") and #text > 3 and #text < 15 then
        local found = false
        for _, known in pairs(RARITY_PATTERNS) do
            if textLower:find(known) then found = true break end
        end
        if not found and not DetectedPatterns.rarities[text] then
            DetectedPatterns.rarities[text] = true
            DebugLog("üîç NOUVELLE RARET√â D√âTECT√âE: " .. text, "success", true)
            table.insert(RARITY_PATTERNS, textLower)
        end
    end
end

-- Interface am√©lior√©e
local Window = Rayfield:CreateWindow({
   Name = "ü™ê Steal Brainrot PREMIUM",
   LoadingTitle = "Steal Brainrot Premium",
   LoadingSubtitle = "by GlamgarOnDiscord - v2.0",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "StealBrainrotConfig",
      FileName = "StealBrainrot"
   },
   Discord = {
      Enabled = false,
   },
   KeySystem = false,
})

-- Onglets
local MainTab = Window:CreateTab("üè† Principal", nil)
local ESPTab = Window:CreateTab("üëÅÔ∏è ESP", nil)
local AutoBuyTab = Window:CreateTab("üõí Auto Buy", nil)
local AutoStealTab = Window:CreateTab("üí∞ Auto Steal", nil)
local FarmTab = Window:CreateTab("‚ö° Auto Farm", nil)
local StatsTab = Window:CreateTab("üìä Statistiques", nil)
local SettingsTab = Window:CreateTab("‚öôÔ∏è Param√®tres", nil)
local DebugTab = Window:CreateTab("üîç Debug", nil)

-- Variables globales
local ESPEnabled = false
local AutoBuyEnabled = false
local SelectedRarities = {}
local espBoxes = {}
local detectedBrainrots = {}

-- Cache des mod√®les potentiels pour √©viter de parcourir tout le workspace √† chaque fois
local cachedModels = {}

local function TrackModel(obj)
    if obj:IsA("Model") and obj.Name ~= "Carpet" then
        cachedModels[obj] = true
    end
end

local function UntrackModel(obj)
    if cachedModels[obj] then
        cachedModels[obj] = nil
    end
end

-- Remplir le cache initialement
for _, obj in ipairs(workspace:GetDescendants()) do
    TrackModel(obj)
end

-- Mettre √† jour le cache dynamiquement
workspace.DescendantAdded:Connect(TrackModel)
workspace.DescendantRemoving:Connect(UntrackModel)

-- Tables de correspondance DYNAMIQUES pour d√©tecter nouvelles raret√©s/mutations
local MUTATION_PATTERNS = {
    -- Mutations existantes
    "gold", "diamond", "rainbow", "lava", "celestial", "bloodrot", "silver",
    -- Nouvelles mutations potentielles
    "crystal", "plasma", "void", "shadow", "neon", "electric", "fire", "ice",
    "cosmic", "galaxy", "starlight", "aurora", "prismatic", "holographic",
    "obsidian", "titanium", "platinum", "emerald", "ruby", "sapphire",
    "quantum", "nuclear", "radioactive", "magnetic", "corrupted", "blessed"
}

local RARITY_PATTERNS = {
    -- Raret√©s existantes
    "common", "rare", "epic", "legendary", "mythic", "god", "secret",
    -- Nouvelles raret√©s potentielles
    "ultimate", "divine", "celestial", "transcendent", "omnipotent", "infinite",
    "eternal", "immortal", "supreme", "absolute", "perfect", "flawless",
    "prime", "apex", "zenith", "pinnacle", "master", "grandmaster"
}

-- D√©tection automatique de nouveaux patterns
local DetectedPatterns = {
    mutations = {},
    rarities = {}
}

local PRICE_MULTIPLIERS = {
    K = 1000,
    M = 1000000,
    B = 1000000000,
    T = 1000000000000
}

-- Conversion d√©di√©e d'un prix texte en nombre
local function ConvertPrice(priceText)
    local numberStr = priceText:match("(%d+)")
    if not numberStr then return 0 end
    local num = tonumber(numberStr) or 0
    for suffix, multiplier in pairs(PRICE_MULTIPLIERS) do
        if priceText:find(suffix) then
            return num * multiplier
        end
    end
    return num
end



-- Fonction pour cr√©er ESP Box
local function CreateESPBox(obj, text, color)
    -- Supprimer ancien ESP s'il existe
    RemoveESPBox(obj)

    local gui
    local success, err = pcall(function()
        gui = Instance.new("BillboardGui")
    end)
    if not success then
        DebugLog("Erreur cr√©ation BillboardGui: " .. tostring(err), "error")
        return
    end

    gui.Name = "ESP_" .. obj.Name
    gui.Adornee = obj
    gui.Size = UDim2.new(0, 200, 0, 100)
    gui.StudsOffset = Vector3.new(0, 2, 0)
    gui.AlwaysOnTop = true
    gui.LightInfluence = 0

    -- Cadre principal
    local frame
    success, err = pcall(function()
        frame = Instance.new("Frame")
    end)
    if not success then
        DebugLog("Erreur cr√©ation Frame: " .. tostring(err), "error")
        return
    end

    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 0.7
    frame.BackgroundColor3 = color
    frame.BorderSizePixel = 2
    frame.BorderColor3 = color
    frame.Parent = gui

    -- Texte
    local label
    success, err = pcall(function()
        label = Instance.new("TextLabel")
    end)
    if not success then
        DebugLog("Erreur cr√©ation TextLabel: " .. tostring(err), "error")
        return
    end

    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextScaled = true
    label.TextStrokeTransparency = 0
    label.TextStrokeColor3 = Color3.new(0, 0, 0)
    label.Font = Enum.Font.GothamBold
    label.Parent = frame

    local parentSuccess, parentErr = pcall(function()
        gui.Parent = game.CoreGui
    end)
    if not parentSuccess then
        DebugLog("Erreur assignation parent GUI: " .. tostring(parentErr), "error")
        return
    end

    espBoxes[obj] = gui
end

-- Fonction pour supprimer ESP Box
local function RemoveESPBox(obj)
    if espBoxes[obj] then
        local success, err = pcall(function()
            espBoxes[obj]:Destroy()
        end)
        if not success then
            DebugLog("Erreur destruction ESPBox: " .. tostring(err), "error")
        end
        espBoxes[obj] = nil
    end
end

-- L'ordre de priorit√© des tests est important :
-- mutation > raret√© > revenu > prix > stolen > nom
local function ParseBrainrotTexts(texts)
    local brainrot = {
        mutation = "None",
        rarity = "Unknown",
        revenue = "N/A",
        price = "N/A",
        priceNumber = 0,
        stolen = false,
        name = "Unknown"
    }

    DebugLog("üìù Parsing textes: " .. table.concat(texts, ", "))

    for _, text in pairs(texts) do
        local textLower = text:lower()
        local processed = false
        
        -- Apprendre de nouveaux patterns
        LearnNewPatterns(text)

        -- 1. Mutations (d√©tection am√©lior√©e)
        for _, pattern in ipairs(MUTATION_PATTERNS) do
            if textLower:find(pattern) then
                brainrot.mutation = text
                DebugLog("‚ú® Mutation trouv√©e: " .. text)
                processed = true
                break
            end
        end

        -- 2. Raret√© (d√©tection am√©lior√©e)
        if not processed then
            for _, pattern in ipairs(RARITY_PATTERNS) do
                if textLower:find(pattern) then
                    brainrot.rarity = text
                    DebugLog("üé® Raret√© trouv√©e: " .. text)
                    processed = true
                    break
                end
            end
        end

        -- 3. G√©n√©ration d'argent ($/s)
        if not processed and (text:find("$/s") or text:find("%$%d+/s")) then
            brainrot.revenue = text
            DebugLog("üí∏ Revenu trouv√©: " .. text)
            processed = true
        end

        -- 4. Prix d'achat ($1K, $500, etc.)
        if not processed and text:find("%$") and not text:find("/s") then
            brainrot.price = text
            brainrot.priceNumber = ConvertPrice(text)
            DebugLog("üí∞ Prix trouv√©: " .. text)
            processed = true
        end

        -- 5. STOLEN
        if not processed and textLower:find("stolen") then
            brainrot.stolen = true
            DebugLog("üö® STOLEN d√©tect√©")
            processed = true
        end

        -- 6. NOM - Tout ce qui reste et qui semble √™tre un nom
        if not processed and text ~= "" and not text:find("%$") and not text:find("/s") then
            brainrot.name = text
            DebugLog("üìù Nom trouv√©: " .. text)
        end
    end

    DebugLog("üìä R√©sultat parsing: " .. brainrot.name .. " | " .. brainrot.rarity .. " | " .. brainrot.price .. " | " .. brainrot.mutation)
    
    -- Mettre √† jour les statistiques
    Stats.BrainrotsDetected = Stats.BrainrotsDetected + 1
    
    return brainrot
end

-- Fonction Auto Steal Players
local function AutoStealPlayers()
    if not AutoStealEnabled then return end
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local humanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local myRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart and myRootPart then
                local distance = (humanoidRootPart.Position - myRootPart.Position).Magnitude
                
                if distance < 50 then -- Proche du joueur
                    DebugLog("üéØ Tentative de vol: " .. otherPlayer.Name .. " (Distance: " .. math.floor(distance) .. ")")
                    
                    -- Chercher RemoteEvents de vol
                    for _, obj in pairs(game.ReplicatedStorage:GetDescendants()) do
                        if obj:IsA("RemoteEvent") then
                            local name = obj.Name:lower()
                            if name:find("steal") or name:find("rob") or name:find("take") then
                                pcall(function()
                                    obj:FireServer(otherPlayer)
                                    Stats.PlayersStolen = Stats.PlayersStolen + 1
                                    DebugLog("üí∞ Vol r√©ussi sur: " .. otherPlayer.Name, "success", true)
                                end)
                                task.wait(1)
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Fonction Auto Farm Money
local function AutoFarmMoney()
    if not AutoFarmMoney then return end
    
    local moneyItems = {}
    
    -- Chercher objets d'argent
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            local name = obj.Name:lower()
            if name:find("cash") or name:find("money") or name:find("coin") or name:find("dollar") then
                table.insert(moneyItems, obj)
            end
        end
    end
    
    -- T√©l√©porter vers les objets d'argent
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        for _, item in pairs(moneyItems) do
            if AutoFarmMoney and item.Parent then
                player.Character.HumanoidRootPart.CFrame = item.CFrame
                task.wait(0.5)
                Stats.MoneyEarned = Stats.MoneyEarned + 1
                DebugLog("üí∞ Argent collect√©: " .. item.Name)
            end
        end
    end
end

-- Fonction de mise √† jour des statistiques
local function UpdatePlayerStats()
    if not PlayerStatsEnabled then return end
    
    local sessionTime = math.floor(tick() - Stats.SessionStart)
    local hours = math.floor(sessionTime / 3600)
    local minutes = math.floor((sessionTime % 3600) / 60)
    local seconds = sessionTime % 60
    
    local timeString = string.format("%02d:%02d:%02d", hours, minutes, seconds)
    
    DebugLog("üìä STATS - Temps: " .. timeString .. " | Brainrots: " .. Stats.BrainrotsDetected .. 
             " | Achats: " .. Stats.BrainrotsBought .. " | Vols: " .. Stats.PlayersStolen)
end

-- Fonction pour d√©tecter tous les brainrots
local function DetectAllBrainrots()
    detectedBrainrots = {}
    
    -- Chercher le tapis
    local carpet = nil
    local map = workspace:FindFirstChild("Map")
    if map then carpet = map:FindFirstChild("Carpet") end
    
    if not carpet then
        DebugLog("‚ùå Tapis non trouv√© pour ESP", "warn")
        return {}
    end
    
    local carpetPos = carpet.Position
    
    -- Scanner uniquement les mod√®les en cache
    for obj, _ in pairs(cachedModels) do
        pcall(function()
            if obj and obj.Parent and obj ~= carpet then
                local modelPos = nil
                if obj.PrimaryPart then
                    modelPos = obj.PrimaryPart.Position
                else
                    pcall(function()
                        local pivot = obj:GetPivot()
                        if pivot then modelPos = pivot.Position end
                    end)
                end

                if modelPos and (modelPos - carpetPos).Magnitude < 100 then
                    -- Collecter tous les textes
                    local texts = {}
                    for _, child in pairs(obj:GetDescendants()) do
                        if child:IsA("TextLabel") and child.Text ~= "" then
                            table.insert(texts, child.Text)
                        end
                    end

                    -- Si 6 textes trouv√©s, c'est probablement un brainrot
                    if #texts >= 5 then -- Au moins 5 textes pour √™tre s√ªr
                        local brainrotData = ParseBrainrotTexts(texts)
                        brainrotData.object = obj
                        brainrotData.position = modelPos
                        brainrotData.allTexts = texts

                        table.insert(detectedBrainrots, brainrotData)

                        DebugLog("üéØ Brainrot d√©tect√©: " .. brainrotData.name .. " | " .. brainrotData.rarity .. " | " .. brainrotData.price)
                    end
                end
            else
                -- Retirer les objets √©loign√©s du cache
                cachedModels[obj] = nil
            end
        end)
    end
    
    DebugLog("üìä Total brainrots d√©tect√©s: " .. #detectedBrainrots)
    return detectedBrainrots
end

-- Fonction pour mettre √† jour l'ESP
local function UpdateESP()
    if not ESPEnabled then return end
    
    -- Nettoyer ancien ESP
    for obj, gui in pairs(espBoxes) do
        RemoveESPBox(obj)
    end
    
    -- D√©tecter brainrots
    local brainrots = DetectAllBrainrots()
    
    -- Cr√©er ESP pour chaque brainrot
    for _, brainrot in pairs(brainrots) do
        local espText = brainrot.rarity .. " - " .. brainrot.name
        if brainrot.price ~= "N/A" then
            espText = espText .. "\nüí∞ " .. brainrot.price
        end
        if brainrot.mutation ~= "None" then
            espText = espText .. "\n‚ú® " .. brainrot.mutation
        end
        if brainrot.stolen then
            espText = espText .. "\nüö® STOLEN"
        end
        
        -- Couleur selon raret√©
        local color = Color3.fromRGB(200, 200, 200) -- Gris par d√©faut
        if brainrot.rarity:find("God") then
            color = Color3.fromRGB(255, 215, 0) -- Or
        elseif brainrot.rarity:find("Secret") then
            color = Color3.fromRGB(255, 255, 255) -- Blanc
        elseif brainrot.rarity == "Legendary" then
            color = Color3.fromRGB(255, 140, 0) -- Orange
        elseif brainrot.rarity == "Mythic" then
            color = Color3.fromRGB(255, 0, 0) -- Rouge
        elseif brainrot.rarity == "Epic" then
            color = Color3.fromRGB(128, 0, 255) -- Violet
        elseif brainrot.rarity == "Rare" then
            color = Color3.fromRGB(0, 100, 255) -- Bleu
        elseif brainrot.rarity == "Common" then
            color = Color3.fromRGB(255, 255, 255) -- Blanc
        end
        
        CreateESPBox(brainrot.object, espText, color)
    end
    
    DebugLog("‚úÖ ESP mis √† jour: " .. #brainrots .. " brainrots affich√©s")
end

-- Fonction pour trouver la base du joueur
local function FindPlayerBase()
    -- Chercher base avec "structure base home"
    for _, obj in pairs(workspace:GetDescendants()) do
        pcall(function()
            if obj:IsA("Model") or obj:IsA("BasePart") then
                local objName = obj.Name:lower()
                if objName:find("structure") and objName:find("base") and objName:find("home") then
                    local position = nil
                    if obj:IsA("BasePart") then
                        position = obj.Position
                    elseif obj:IsA("Model") and obj.PrimaryPart then
                        position = obj.PrimaryPart.Position
                    end
                    
                    if position then
                        DebugLog("üè† Base trouv√©e: " .. obj:GetFullName() .. " √† " .. tostring(position))
                        return position
                    end
                end
            end
        end)
    end
    
    -- Fallback: position actuelle
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return player.Character.HumanoidRootPart.Position
    end
    
    return nil
end

-- Fonction Auto Buy avec suivi am√©lior√©
local function AutoBuyBrainrots()
    if not AutoBuyEnabled then return end
    
    local brainrots = DetectAllBrainrots()
    local targetBrainrots = {}
    
    -- Filtrer selon les raret√©s s√©lectionn√©es
    for _, brainrot in pairs(brainrots) do
        for rarity, selected in pairs(SelectedRarities) do
            if selected and brainrot.rarity:find(rarity) then
                table.insert(targetBrainrots, brainrot)
                break
            end
        end
    end
    
    -- Trier par priorit√© (God > Secret > Legendary > Mythic > Epic > Rare > Common)
    local rarityPriority = {
        ["God"] = 7,
        ["Secret"] = 6,
        ["Legendary"] = 5,
        ["Mythic"] = 4,
        ["Epic"] = 3,
        ["Rare"] = 2,
        ["Common"] = 1
    }
    
    table.sort(targetBrainrots, function(a, b)
        local priorityA = 0
        local priorityB = 0
        
        for rarity, priority in pairs(rarityPriority) do
            if a.rarity:find(rarity) then priorityA = priority end
            if b.rarity:find(rarity) then priorityB = priority end
        end
        
        return priorityA > priorityB
    end)
    
    -- Acheter et suivre le premier brainrot disponible
    for _, brainrot in pairs(targetBrainrots) do
        if not AutoBuyEnabled then
            DebugLog("‚õî Auto Buy interrompu (d√©sactiv√©)")
            return
        end

        if not brainrot.stolen then
            DebugLog("üõí Processus d'achat: " .. brainrot.name .. " (" .. brainrot.rarity .. ") - " .. brainrot.price)
            
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local character = player.Character
                local humanoidRootPart = character.HumanoidRootPart
                
                -- √âtape 1: Aller √† c√¥t√© du brainrot
                DebugLog("üìç √âtape 1: Se t√©l√©porter √† c√¥t√© du brainrot")
                local nearPosition = brainrot.position + Vector3.new(3, 2, 3)
                humanoidRootPart.CFrame = CFrame.new(nearPosition)
                task.wait(1)
                
                -- √âtape 2: Essayer d'acheter avec E
                DebugLog("üí∞ √âtape 2: Tentative d'achat avec E")
                local VirtualInputManager = game:GetService("VirtualInputManager")
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(1)
                
                -- √âtape 3: Suivre le brainrot vers la base
                DebugLog("üèÉ √âtape 3: Suivi du brainrot vers la base")
                local basePosition = FindPlayerBase()
                
                if basePosition then
                    for i = 1, 20 do
                        if not AutoBuyEnabled then
                            DebugLog("‚õî Suivi interrompu (Auto Buy d√©sactiv√©)")
                            return
                        end
                        
                        pcall(function()
                            if brainrot.object and brainrot.object.Parent then
                                local currentBrainrotPos = nil
                                
                                if brainrot.object.PrimaryPart then
                                    currentBrainrotPos = brainrot.object.PrimaryPart.Position
                                else
                                    local pivot = brainrot.object:GetPivot()
                                    if pivot then currentBrainrotPos = pivot.Position end
                                end

                                if currentBrainrotPos then
                                    local followPos = currentBrainrotPos + Vector3.new(2, 1, 2)
                                    humanoidRootPart.CFrame = CFrame.new(followPos)
                                    
                                    local distanceToBase = (currentBrainrotPos - basePosition).Magnitude
                                    if distanceToBase < 20 then
                                        DebugLog("üè† Brainrot arriv√© √† la base !")
                                        Stats.BrainrotsBought = Stats.BrainrotsBought + 1
                                        SendDiscordWebhook("üõí Achat R√©ussi", 
                                            "Brainrot achet√©: " .. brainrot.name .. " (" .. brainrot.rarity .. ")", 65280)
                                        return
                                    end
                                end
                            end
                        end)
                        
                        task.wait(1)
                    end
                end
                
                break
            end
        end
    end
end

-- === ONGLETS ===

-- Onglet Principal
local WelcomeSection = MainTab:CreateSection("üè† Bienvenue")

MainTab:CreateLabel("ü™ê Steal Brainrot Premium v2.0")
MainTab:CreateLabel("üí´ Cr√©√© par GlamgarOnDiscord")
MainTab:CreateLabel("üöÄ Version compl√®te avec toutes les fonctionnalit√©s premium")

local StatusSection = MainTab:CreateSection("üìä Status Actuel")

local StatusLabel = MainTab:CreateLabel("üî¥ Syst√®mes: Arr√™t√©s")

-- Fonction pour mettre √† jour le status
local function UpdateStatus()
    local activeFeatures = {}
    if ESPEnabled then table.insert(activeFeatures, "ESP") end
    if AutoBuyEnabled then table.insert(activeFeatures, "Auto Buy") end
    if AutoStealEnabled then table.insert(activeFeatures, "Auto Steal") end
    if AutoFarmMoney then table.insert(activeFeatures, "Auto Farm") end
    
    if #activeFeatures > 0 then
        StatusLabel.Text = "üü¢ Actifs: " .. table.concat(activeFeatures, ", ")
    else
        StatusLabel.Text = "üî¥ Syst√®mes: Arr√™t√©s"
    end
end

local QuickStartSection = MainTab:CreateSection("‚ö° D√©marrage Rapide")

local QuickESPButton = MainTab:CreateButton({
   Name = "üëÅÔ∏è Activer ESP Rapide",
   Callback = function()
      ESPEnabled = true
      DebugLog("üëÅÔ∏è ESP ACTIV√â via d√©marrage rapide")
      spawn(function()
         while ESPEnabled do
            UpdateESP()
            task.wait(3)
         end
      end)
   end,
})

local QuickBuyButton = MainTab:CreateButton({
   Name = "üõí Auto Buy God+Secret",
   Callback = function()
      SelectedRarities["God"] = true
      SelectedRarities["Secret"] = true
      AutoBuyEnabled = true
      DebugLog("üõí AUTO BUY ACTIV√â (God + Secret)")
      spawn(function()
         while AutoBuyEnabled do
            AutoBuyBrainrots()
            task.wait(10)
         end
      end)
   end,
})

-- ESP Tab
local ESPConfigSection = ESPTab:CreateSection("‚öôÔ∏è Configuration ESP")

local ESPToggle = ESPTab:CreateToggle({
   Name = "üëÅÔ∏è ESP Brainrots",
   CurrentValue = false,
   Callback = function(Value)
      ESPEnabled = Value
      UpdateStatus()
      if Value then
         DebugLog("üëÅÔ∏è ESP ACTIV√â")
         spawn(function()
            while ESPEnabled do
               UpdateESP()
               task.wait(3)
            end
         end)
      else
         DebugLog("üëÅÔ∏è ESP D√âSACTIV√â")
         for obj, gui in pairs(espBoxes) do
            RemoveESPBox(obj)
         end
      end
   end,
})

local ESPDistanceSlider = ESPTab:CreateSlider({
   Name = "üìè Distance ESP (studs)",
   Range = {50, 500},
   Increment = 10,
   Suffix = " studs",
   CurrentValue = 100,
   Callback = function(Value)
      DebugLog("üìè Distance ESP: " .. Value .. " studs")
   end,
})

-- Auto Steal Tab
local AutoStealSection = AutoStealTab:CreateSection("üéØ Configuration Auto Steal")

local AutoStealToggle = AutoStealTab:CreateToggle({
   Name = "üí∞ Auto Steal Players",
   CurrentValue = false,
   Callback = function(Value)
      AutoStealEnabled = Value
      UpdateStatus()
      if Value then
         DebugLog("üí∞ AUTO STEAL ACTIV√â")
         spawn(function()
            while AutoStealEnabled do
               AutoStealPlayers()
               task.wait(5)
            end
         end)
      else
         DebugLog("üí∞ AUTO STEAL D√âSACTIV√â")
      end
   end,
})

local StealDistanceSlider = AutoStealTab:CreateSlider({
   Name = "üìè Distance Vol (studs)",
   Range = {10, 100},
   Increment = 5,
   Suffix = " studs",
   CurrentValue = 50,
   Callback = function(Value)
      DebugLog("üìè Distance vol: " .. Value .. " studs")
   end,
})

-- Farm Tab
local FarmSection = FarmTab:CreateSection("‚ö° Configuration Farm")

local AutoFarmToggle = FarmTab:CreateToggle({
   Name = "üí∞ Auto Farm Money",
   CurrentValue = false,
   Callback = function(Value)
      AutoFarmMoney = Value
      UpdateStatus()
      if Value then
         DebugLog("üí∞ AUTO FARM ACTIV√â")
         spawn(function()
            while AutoFarmMoney do
               AutoFarmMoney()
               task.wait(3)
            end
         end)
      else
         DebugLog("üí∞ AUTO FARM D√âSACTIV√â")
      end
   end,
})

local WalkSpeedSlider = FarmTab:CreateSlider({
   Name = "üèÉ Vitesse de Marche",
   Range = {16, 100},
   Increment = 1,
   Suffix = " studs/s",
   CurrentValue = 16,
   Callback = function(Value)
      WalkSpeed = Value
      if player.Character and player.Character:FindFirstChild("Humanoid") then
         player.Character.Humanoid.WalkSpeed = Value
      end
      DebugLog("üèÉ Vitesse: " .. Value .. " studs/s")
   end,
})

-- Stats Tab
local StatsSection = StatsTab:CreateSection("üìä Statistiques en Temps R√©el")

local StatsToggle = StatsTab:CreateToggle({
   Name = "üìä Afficher Statistiques",
   CurrentValue = false,
   Callback = function(Value)
      PlayerStatsEnabled = Value
      if Value then
         spawn(function()
            while PlayerStatsEnabled do
               UpdatePlayerStats()
               task.wait(10)
            end
         end)
      end
   end,
})

StatsTab:CreateLabel("üéØ Brainrots D√©tect√©s: " .. Stats.BrainrotsDetected)
StatsTab:CreateLabel("üõí Brainrots Achet√©s: " .. Stats.BrainrotsBought)
StatsTab:CreateLabel("üí∞ Argent Collect√©: " .. Stats.MoneyEarned)
StatsTab:CreateLabel("üë• Joueurs Vol√©s: " .. Stats.PlayersStolen)

-- Settings Tab
local WebhookSection = SettingsTab:CreateSection("üîó Webhook Discord")

local WebhookInput = SettingsTab:CreateInput({
   Name = "üîó URL Webhook Discord",
   PlaceholderText = "https://discord.com/api/webhooks/...",
   RemoveTextAfterFocusLost = false,
   Callback = function(Text)
      WebhookUrl = Text
      DebugLog("üîó Webhook configur√©")
   end,
})

local TestWebhookButton = SettingsTab:CreateButton({
   Name = "üß™ Tester Webhook",
   Callback = function()
      SendDiscordWebhook("üß™ Test Webhook", "Webhook fonctionnel ! ‚úÖ", 65280)
      DebugLog("üß™ Test webhook envoy√©")
   end,
})

local GeneralSection = SettingsTab:CreateSection("‚öôÔ∏è Param√®tres G√©n√©raux")

local DebugToggle = SettingsTab:CreateToggle({
   Name = "üîç Mode Debug",
   CurrentValue = true,
   Callback = function(Value)
      DebugMode = Value
      DebugLog("üîç Debug: " .. (Value and "ACTIV√â" or "D√âSACTIV√â"))
   end,
})

-- Auto Buy Tab
local RaritySection = AutoBuyTab:CreateSection("üéØ S√©lection des Raret√©s")

AutoBuyTab:CreateLabel("S√©lectionnez les raret√©s √† acheter automatiquement:")

-- Toggles pour chaque raret√© avec √©mojis
local rarities = {
    {name = "God", emoji = "üëë", color = "Or"},
    {name = "Secret", emoji = "üîÆ", color = "Blanc"},
    {name = "Legendary", emoji = "üß°", color = "Orange"},
    {name = "Mythic", emoji = "‚ù§Ô∏è", color = "Rouge"},
    {name = "Epic", emoji = "üíú", color = "Violet"},
    {name = "Rare", emoji = "üíô", color = "Bleu"},
    {name = "Common", emoji = "ü§ç", color = "Blanc"}
}

for _, rarity in pairs(rarities) do
    local toggle = AutoBuyTab:CreateToggle({
        Name = rarity.emoji .. " " .. rarity.name .. " (" .. rarity.color .. ")",
        CurrentValue = false,
        Callback = function(Value)
            SelectedRarities[rarity.name] = Value
            DebugLog("üéØ " .. rarity.name .. ": " .. (Value and "ACTIV√â" or "D√âSACTIV√â"))
        end,
    })
end

local AutoBuyConfigSection = AutoBuyTab:CreateSection("‚öôÔ∏è Configuration Auto Buy")

local AutoBuyDelaySlider = AutoBuyTab:CreateSlider({
   Name = "‚è±Ô∏è D√©lai entre achats (secondes)",
   Range = {5, 60},
   Increment = 5,
   Suffix = "s",
   CurrentValue = 10,
   Callback = function(Value)
      DebugLog("‚è±Ô∏è D√©lai Auto Buy: " .. Value .. "s")
   end,
})

local AutoBuyToggle = AutoBuyTab:CreateToggle({
   Name = "üõí Activer Auto Buy",
   CurrentValue = false,
   Callback = function(Value)
      AutoBuyEnabled = Value
      UpdateStatus()
      if Value then
         DebugLog("üõí AUTO BUY ACTIV√â")
         spawn(function()
            while AutoBuyEnabled do
               AutoBuyBrainrots()
               task.wait(10) -- V√©rifier toutes les 10 secondes pour √©viter spam
            end
         end)
      else
         DebugLog("üõí AUTO BUY D√âSACTIV√â")
      end
   end,
})

-- === BOUTONS DEBUG ===

-- 1. Debug tous les Parts et Carpet
local AllPartsButton = DebugTab:CreateButton({
   Name = "üß© Debug Tous Parts + Carpet",
   Callback = function()
      DebugLog("=== üß© DEBUG TOUS PARTS + CARPET ===")
      
      local partCount = 0
      local carpetFound = false
      
      for _, obj in pairs(workspace:GetDescendants()) do
         pcall(function()
            if obj:IsA("BasePart") then
               partCount = partCount + 1
               
               -- Chercher sp√©cifiquement "Carpet"
               if obj.Name:lower():find("carpet") then
                  carpetFound = true
                  DebugLog("üî¥ CARPET TROUV√â: " .. obj:GetFullName())
                  DebugLog("  üìç Position: " .. tostring(obj.Position))
                  DebugLog("  üìè Taille: " .. tostring(obj.Size))
                  DebugLog("  üé® Couleur: " .. tostring(obj.BrickColor))
                  DebugLog("  üß± Mat√©riau: " .. tostring(obj.Material))
               end
               
               -- Limiter l'affichage pour pas spam
               if partCount <= 50 then
                  DebugLog("üß© Part: " .. obj.Name .. " | " .. obj:GetFullName())
               end
            end
         end)
      end
      
      DebugLog("üìä Total Parts trouv√©s: " .. partCount)
      DebugLog("üî¥ Carpet trouv√©: " .. (carpetFound and "‚úÖ OUI" or "‚ùå NON"))
      DebugLog("=== FIN DEBUG PARTS ===")
   end,
})

-- 2. Debug Models avec textes sp√©cifiques
local SpecificTextsButton = DebugTab:CreateButton({
   Name = "üìù Models avec Textes Sp√©cifiques",
   Callback = function()
      DebugLog("=== üìù MODELS AVEC TEXTES SP√âCIFIQUES ===")
      
      local targetTexts = {
         "Mythic", "Legendary", "Common", "Epic", "Rare", "Brainrot God", "Secret"
      }
      
      local foundModels = {}
      
      -- Scanner tous les Models
      for _, obj in pairs(workspace:GetDescendants()) do
         pcall(function()
            if obj:IsA("Model") then
               local modelTexts = {}
               local hasTargetText = false
               
               -- Chercher TextLabels dans ce Model
               for _, child in pairs(obj:GetDescendants()) do
                  pcall(function()
                     if child:IsA("TextLabel") and child.Text and child.Text ~= "" then
                        table.insert(modelTexts, child.Text)
                        
                        -- V√©rifier si c'est un texte cible
                        for _, target in pairs(targetTexts) do
                           if child.Text:find(target) then
                              hasTargetText = true
                           end
                        end
                     end
                  end)
               end
               
               -- Si le Model a un texte cible, l'afficher
               if hasTargetText then
                  table.insert(foundModels, {
                     model = obj,
                     texts = modelTexts
                  })
                  
                  DebugLog("üéØ MODEL TROUV√â: " .. obj.Name)
                  DebugLog("  üîó Path: " .. obj:GetFullName())
                  DebugLog("  üìù Textes (" .. #modelTexts .. "):")
                  for i, text in pairs(modelTexts) do
                     -- Marquer les textes cibles
                     local isTarget = false
                     for _, target in pairs(targetTexts) do
                        if text:find(target) then
                           isTarget = true
                           break
                        end
                     end
                     DebugLog("    " .. i .. ". '" .. text .. "'" .. (isTarget and " ‚≠ê TARGET" or ""))
                  end
                  DebugLog("  üìç Position: " .. (obj.PrimaryPart and tostring(obj.PrimaryPart.Position) or "N/A"))
               end
            end
         end)
      end
      
      DebugLog("üìä Models avec textes cibles: " .. #foundModels)
      DebugLog("üéØ Textes recherch√©s: " .. table.concat(targetTexts, ", "))
      DebugLog("=== FIN DEBUG TEXTES ===")
   end,
})

-- 3. Debug sp√©cifique Workspace.Map.Carpet
local CarpetPathButton = DebugTab:CreateButton({
   Name = "üî¥ Test Workspace.Map.Carpet",
   Callback = function()
      DebugLog("=== üî¥ TEST WORKSPACE.MAP.CARPET ===")
      
      -- Test path exact
      local map = workspace:FindFirstChild("Map")
      if map then
         DebugLog("‚úÖ Map trouv√©: " .. map:GetFullName())
         
         local carpet = map:FindFirstChild("Carpet")
         if carpet then
            DebugLog("‚úÖ Carpet trouv√©: " .. carpet:GetFullName())
            DebugLog("  üìç Position: " .. tostring(carpet.Position))
            DebugLog("  üìè Taille: " .. tostring(carpet.Size))
            DebugLog("  üé® Couleur: " .. tostring(carpet.BrickColor))
            DebugLog("  üß± Mat√©riau: " .. tostring(carpet.Material))
            DebugLog("  üì¶ Type: " .. carpet.ClassName)
         else
            DebugLog("‚ùå Carpet pas trouv√© dans Map")
            DebugLog("üìÅ Contenu de Map:")
            for _, child in pairs(map:GetChildren()) do
               DebugLog("  - " .. child.Name .. " (" .. child.ClassName .. ")")
            end
         end
      else
         DebugLog("‚ùå Map pas trouv√© dans Workspace")
         DebugLog("üìÅ Contenu de Workspace (50 premiers):")
         local count = 0
         for _, child in pairs(workspace:GetChildren()) do
            count = count + 1
            if count <= 50 then
               DebugLog("  - " .. child.Name .. " (" .. child.ClassName .. ")")
            end
         end
      end
      
      DebugLog("=== FIN TEST CARPET ===")
   end,
})

-- 4. Debug sp√©cifique Workspace.movingAnimals
local MovingAnimalsButton = DebugTab:CreateButton({
   Name = "üêæ Test Workspace.movingAnimals",
   Callback = function()
      DebugLog("=== üêæ TEST WORKSPACE.MOVINGANIMALS ===")
      
      local movingAnimals = workspace:FindFirstChild("movingAnimals")
      if movingAnimals then
         DebugLog("‚úÖ movingAnimals trouv√©: " .. movingAnimals:GetFullName())
         DebugLog("üì¶ Nombre d'enfants: " .. #movingAnimals:GetChildren())
         
         for _, child in pairs(movingAnimals:GetChildren()) do
            pcall(function()
               if child:IsA("Model") then
                  DebugLog("üì¶ Model: " .. child.Name)
                  
                  -- Chercher HumanoidRootPart
                  local humanoidRootPart = child:FindFirstChild("HumanoidRootPart")
                  if humanoidRootPart then
                     DebugLog("  ‚úÖ HumanoidRootPart: " .. humanoidRootPart:GetFullName())
                  else
                     DebugLog("  ‚ùå Pas de HumanoidRootPart")
                  end
                  
                  -- Compter et lister TextLabels
                  local textLabels = {}
                  for _, desc in pairs(child:GetDescendants()) do
                     if desc:IsA("TextLabel") and desc.Text ~= "" then
                        table.insert(textLabels, desc.Text)
                     end
                  end
                  
                  DebugLog("  üìù TextLabels (" .. #textLabels .. "):")
                  for i, text in pairs(textLabels) do
                     DebugLog("    " .. i .. ". '" .. text .. "'")
                  end
               end
            end)
         end
      else
         DebugLog("‚ùå movingAnimals pas trouv√© dans Workspace")
      end
      
      DebugLog("=== FIN TEST MOVINGANIMALS ===")
   end,
})

-- 5. Debug Models sur le Tapis
local ModelsOnCarpetButton = DebugTab:CreateButton({
   Name = "üéØ Models sur le Tapis",
   Callback = function()
      DebugLog("=== üéØ MODELS SUR LE TAPIS ===")
      
      -- Trouver le tapis d'abord
      local carpet = nil
      local map = workspace:FindFirstChild("Map")
      if map then
         carpet = map:FindFirstChild("Carpet")
      end
      
      if not carpet then
         DebugLog("‚ùå Tapis non trouv√© - impossible de d√©tecter les models dessus")
         return
      end
      
      DebugLog("‚úÖ Tapis trouv√©: " .. carpet:GetFullName())
      DebugLog("üìç Position tapis: " .. tostring(carpet.Position))
      
      local carpetPos = carpet.Position
      local modelsOnCarpet = {}
      
      -- Chercher models proches du tapis
      for _, obj in pairs(workspace:GetDescendants()) do
         pcall(function()
            if obj:IsA("Model") and obj ~= carpet and obj.Name ~= "Camera" and obj.Name ~= "Terrain" then
               local modelPos = nil
               
               if obj.PrimaryPart then
                  modelPos = obj.PrimaryPart.Position
               else
                  pcall(function()
                     local pivot = obj:GetPivot()
                     if pivot then
                        modelPos = pivot.Position
                     end
                  end)
               end
               
               if modelPos then
                  local distance = (modelPos - carpetPos).Magnitude
                  if distance < 100 then -- Proche du tapis
                     -- Chercher textes cibles
                     local targetTexts = {
                        "Mythic", "Legendary", "Common", "Epic", "Rare", "Brainrot God", "Secret"
                     }
                     local modelTexts = {}
                     local hasTargetText = false
                     
                     for _, child in pairs(obj:GetDescendants()) do
                        pcall(function()
                           if child:IsA("TextLabel") and child.Text and child.Text ~= "" then
                              table.insert(modelTexts, child.Text)
                              for _, target in pairs(targetTexts) do
                                 if child.Text:find(target) then
                                    hasTargetText = true
                                 end
                              end
                           end
                        end)
                     end
                     
                     if hasTargetText then
                        table.insert(modelsOnCarpet, {
                           model = obj,
                           distance = distance,
                           texts = modelTexts
                        })
                        
                        DebugLog("üéØ MODEL SUR TAPIS: " .. obj.Name)
                        DebugLog("  üìè Distance: " .. math.floor(distance) .. " unit√©s")
                        DebugLog("  üìç Position: " .. tostring(modelPos))
                        DebugLog("  üìù Textes:")
                        for i, text in pairs(modelTexts) do
                           local isTarget = false
                           for _, target in pairs(targetTexts) do
                              if text:find(target) then isTarget = true break end
                           end
                           DebugLog("    " .. i .. ". '" .. text .. "'" .. (isTarget and " ‚≠ê" or ""))
                        end
                     end
                  end
               end
            end
         end)
      end
      
      DebugLog("üìä Models avec textes cibles sur tapis: " .. #modelsOnCarpet)
      DebugLog("=== FIN MODELS SUR TAPIS ===")
   end,
})

-- 6. Test Parsing des Noms
local TestParsingButton = DebugTab:CreateButton({
   Name = "üìù Test Parsing Noms",
   Callback = function()
      DebugLog("=== üìù TEST PARSING NOMS ===")
      
      local brainrots = DetectAllBrainrots()
      
      DebugLog("üìä Brainrots trouv√©s: " .. #brainrots)
      
      for i, brainrot in pairs(brainrots) do
         DebugLog("--- BRAINROT " .. i .. " ---")
         DebugLog("  üìù Nom: '" .. brainrot.name .. "'")
         DebugLog("  üé® Raret√©: '" .. brainrot.rarity .. "'")
         DebugLog("  üí∞ Prix: '" .. brainrot.price .. "'")
         DebugLog("  üí∏ Revenu: '" .. brainrot.revenue .. "'")
         DebugLog("  ‚ú® Mutation: '" .. brainrot.mutation .. "'")
         DebugLog("  üö® STOLEN: " .. tostring(brainrot.stolen))
         DebugLog("  üìÑ Tous textes: " .. table.concat(brainrot.allTexts, " | "))
      end
      
      DebugLog("=== FIN TEST PARSING ===")
   end,
})

-- 7. Scan complet Workspace
local FullWorkspaceScanButton = DebugTab:CreateButton({
   Name = "üåç Scan Complet Workspace",
   Callback = function()
      DebugLog("=== üåç SCAN COMPLET WORKSPACE ===")
      
      local stats = {
         models = 0,
         parts = 0,
         textLabels = 0,
         targetModels = 0
      }
      
      local targetTexts = {
         "Mythic", "Legendary", "Common", "Epic", "Rare", "Brainrot God", "Secret"
      }
      
      for _, obj in pairs(workspace:GetDescendants()) do
         pcall(function()
            if obj:IsA("Model") then
               stats.models = stats.models + 1
               
               -- Chercher textes cibles dans ce model
               local hasTarget = false
               for _, child in pairs(obj:GetDescendants()) do
                  if child:IsA("TextLabel") and child.Text then
                     stats.textLabels = stats.textLabels + 1
                     for _, target in pairs(targetTexts) do
                        if child.Text:find(target) then
                           hasTarget = true
                           break
                        end
                     end
                  end
               end
               
               if hasTarget then
                  stats.targetModels = stats.targetModels + 1
               end
               
            elseif obj:IsA("BasePart") then
               stats.parts = stats.parts + 1
            end
         end)
      end
      
      DebugLog("üìä STATISTIQUES WORKSPACE:")
      DebugLog("  üì¶ Models totaux: " .. stats.models)
      DebugLog("  üß© Parts totaux: " .. stats.parts)
      DebugLog("  üìù TextLabels totaux: " .. stats.textLabels)
      DebugLog("  üéØ Models avec textes cibles: " .. stats.targetModels)
      DebugLog("  üîç Textes recherch√©s: " .. table.concat(targetTexts, ", "))
      
      DebugLog("=== FIN SCAN COMPLET ===")
   end,
})

-- Message de bienvenue am√©lior√©
Rayfield:Notify({
   Title = "ü™ê Steal Brainrot PREMIUM v2.0",
   Content = "ESP Avanc√© + Auto Buy + Auto Steal + Stats + Webhooks - Premium Edition !",
   Duration = 6,
   Image = nil,
})

-- D√©marrage automatique des syst√®mes
spawn(function()
    task.wait(2)
    DebugLog("üöÄ STEAL BRAINROT PREMIUM v2.0 - Pr√™t √† utiliser !")
    DebugLog("üëÅÔ∏è ESP avec box color√©es et d√©tection dynamique")
    DebugLog("üõí Auto Buy avec suivi intelligent vers base")
    DebugLog("üí∞ Auto Steal players + Auto Farm money")
    DebugLog("üìä Statistiques en temps r√©el")
    DebugLog("üîó Support Webhooks Discord")
    DebugLog("üîç D√©tection automatique nouvelles raret√©s/mutations")
    DebugLog("‚öôÔ∏è Configuration sauvegard√©e automatiquement")
    
    -- Notification webhook de d√©marrage
    if WebhookUrl ~= "" then
        SendDiscordWebhook("üöÄ Script D√©marr√©", 
            "Steal Brainrot Premium v2.0 lanc√© avec succ√®s pour " .. player.Name, 3066993)
    end
end)

-- Mise √† jour automatique de la vitesse de marche
spawn(function()
    while true do
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            if player.Character.Humanoid.WalkSpeed ~= WalkSpeed then
                player.Character.Humanoid.WalkSpeed = WalkSpeed
            end
        end
        task.wait(1)
    end
end)

-- Syst√®me de sauvegarde automatique des statistiques
spawn(function()
    while true do
        task.wait(60) -- Sauvegarder toutes les minutes
        if PlayerStatsEnabled then
            local sessionTime = math.floor(tick() - Stats.SessionStart)
            if sessionTime > 0 and sessionTime % 300 == 0 then -- Toutes les 5 minutes
                SendDiscordWebhook("üìä Rapport Statistiques", 
                    string.format("Session: %d min | Brainrots: %d | Achats: %d | Vols: %d", 
                    math.floor(sessionTime/60), Stats.BrainrotsDetected, Stats.BrainrotsBought, Stats.PlayersStolen), 3447003)
            end
        end
    end
end)
